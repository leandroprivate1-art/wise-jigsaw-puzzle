<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ§© Jigsaw Adventure!</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
:root {
  --coral: #FF6B6B; --sky: #4ECDC4; --sun: #FFE66D;
  --grape: #A855F7; --mint: #6EE7B7; --peach: #FDBA74;
  --dark: #1E1B4B; --card: rgba(255,255,255,0.95);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Nunito', sans-serif;
  background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
  min-height: 100vh; overflow-x: hidden; color: #fff;
}

.stars-bg { position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden; }
.star { position: absolute; border-radius: 50%; background: #fff; animation: twinkle var(--d, 3s) ease-in-out infinite; }
@keyframes twinkle {
  0%, 100% { opacity: 0.2; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.4); }
}

.floater {
  position: absolute;
  border-radius: 50%;
  animation: float var(--fd, 8s) ease-in-out infinite;
  opacity: 0.15;
}
@keyframes float {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  50% { transform: translateY(-30px) rotate(180deg); }
}

#root { position: relative; z-index: 1; }
.app { max-width: 1150px; margin: 0 auto; padding: 16px; }

.header { text-align: center; padding: 16px 0 20px; }
.header h1 {
  font-family: 'Fredoka One', cursive;
  font-size: clamp(2rem, 5vw, 3.2rem);
  background: linear-gradient(135deg, var(--sun), var(--coral), var(--grape));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 2px 8px rgba(255,230,109,0.4));
  letter-spacing: 2px;
}
.header p { color: rgba(255,255,255,0.7); font-size: 1rem; margin-top: 4px; }

.upload-wrap { display: flex; flex-direction: column; align-items: center; gap: 20px; padding: 20px; }
.upload-zone {
  background: rgba(255,255,255,0.08);
  border: 3px dashed rgba(255,255,255,0.4);
  border-radius: 24px;
  padding: 3rem 4rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s;
  max-width: 480px; width: 100%;
  backdrop-filter: blur(10px);
}
.upload-zone:hover {
  background: rgba(255,255,255,0.15);
  border-color: var(--sun);
  transform: scale(1.02);
}
.upload-zone .icon { font-size: 4rem; display: block; margin-bottom: 12px; animation: bounce 2s ease-in-out infinite; }
@keyframes bounce { 0%,100%{transform:translateY(0)}50%{transform:translateY(-10px)} }
.upload-zone h2 { font-family:'Fredoka One',cursive; font-size:1.6rem; color: var(--sun); }
.upload-zone p { color: rgba(255,255,255,0.6); margin-top: 6px; }

.sample-btn {
  background: linear-gradient(135deg, var(--coral), var(--grape));
  color: #fff; border: none; border-radius: 50px; padding: 14px 32px;
  font-family: 'Fredoka One', cursive; font-size: 1.1rem; cursor: pointer;
  box-shadow: 0 4px 20px rgba(255,107,107,0.4); transition: all 0.2s;
}
.sample-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 28px rgba(255,107,107,0.5); }

.game-layout { display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap; }
.game-layout .sidebar { flex: 0 0 220px; }
.game-layout .main-area { flex: 1; min-width: 0; }

.sidebar {
  background: rgba(255,255,255,0.1); backdrop-filter: blur(12px);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 20px; padding: 16px;
}
.sidebar-section { margin-bottom: 14px; }
.sidebar-section label { display: block; font-weight: 700; font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px; }
.sidebar select {
  width: 100%; padding: 10px 14px; border: 2px solid rgba(255,255,255,0.2);
  border-radius: 12px; background: rgba(255,255,255,0.1); color: #fff;
  font-family: 'Nunito', sans-serif; font-size: 0.95rem; cursor: pointer; outline: none;
  transition: border-color 0.2s;
}
.sidebar select:hover { border-color: var(--sun); }
.sidebar select option { background: #302b63; color: #fff; }

.btn {
  display: block; width: 100%; padding: 11px; border: none; border-radius: 14px;
  font-family: 'Fredoka One', cursive; font-size: 1rem; cursor: pointer;
  transition: all 0.2s; text-align: center; margin-bottom: 8px;
}
.btn:hover { transform: translateY(-2px); }
.btn:active { transform: scale(0.97); }
.btn-primary { background: linear-gradient(135deg, var(--coral), #ff8c42); color: #fff; box-shadow: 0 4px 14px rgba(255,107,107,0.35); }
.btn-teal { background: linear-gradient(135deg, var(--sky), #0891b2); color: #fff; box-shadow: 0 4px 14px rgba(78,205,196,0.35); }
.btn-purple { background: linear-gradient(135deg, var(--grape), #6d28d9); color: #fff; box-shadow: 0 4px 14px rgba(168,85,247,0.35); }
.btn-outline { background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); color: #fff; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

.stats-bar {
  display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;
  margin-bottom: 12px;
}
.stat-chip {
  background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.2);
  border-radius: 50px; padding: 6px 16px; display: flex; align-items: center; gap: 6px;
  font-family: 'Fredoka One', cursive; font-size: 1rem;
}

.board-area {
  background: rgba(0,0,0,0.25); border-radius: 20px;
  padding: 14px; display: inline-block; position: relative;
  border: 2px solid rgba(255,255,255,0.1);
}
.board-wrap { position: relative; }
.puzzle-board {
  display: grid; gap: 0; overflow: visible;
  background: rgba(255,255,255,0.05);
}
.puzzle-slot {
  position: relative; overflow: visible;
  display: flex; align-items: center; justify-content: center;
  background: rgba(255,255,255,0.05);
  border: 1px dashed rgba(255,255,255,0.12);
  transition: all 0.2s;
}
.puzzle-slot.hover-target {
  background: rgba(78, 205, 196, 0.3);
  border-color: var(--sky);
  box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
}
.puzzle-slot.correct-target {
  background: rgba(110, 231, 183, 0.4);
  border-color: var(--mint);
  box-shadow: 0 0 20px rgba(110, 231, 183, 0.6);
}
.slot-inner {
  position: absolute; inset: 0;
  display: flex; align-items: center; justify-content: center;
}
.slot-hint { font-size: 1.2rem; opacity: 0.3; font-family: 'Fredoka One', cursive; }
.piece-img {
  position: absolute; cursor: grab; transition: filter 0.15s, transform 0.2s;
  image-rendering: auto;
}
.piece-img:active { cursor: grabbing; }
.piece-img.locked { cursor: default; pointer-events: none; filter: brightness(1.1); }
.piece-img.placed { animation: placeSnap 0.35s cubic-bezier(0.175,0.885,0.32,1.275); }
@keyframes placeSnap {
  0% { transform: scale(1.15) rotate(3deg); }
  60% { transform: scale(0.95); }
  100% { transform: scale(1) rotate(0); }
}

.drag-ghost {
  position: fixed; pointer-events: none; z-index: 9999;
  opacity: 0.95; filter: drop-shadow(0 12px 24px rgba(0,0,0,0.5));
  transform: scale(1.08);
}

.pile-section {
  margin-top: 14px;
  background: rgba(255,255,255,0.06);
  border-radius: 16px; padding: 12px;
  border: 1px solid rgba(255,255,255,0.12);
}
.pile-title { font-family:'Fredoka One',cursive; font-size: 1rem; margin-bottom: 10px; }
.pile-container {
  display: flex; flex-wrap: wrap; gap: 6px;
  justify-content: flex-start; max-height: 220px;
  overflow-y: auto; padding: 4px;
}
.pile-container::-webkit-scrollbar { width: 6px; }
.pile-container::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
.pile-piece {
  border-radius: 6px; cursor: grab; transition: transform 0.15s;
  border: 2px solid transparent;
}
.pile-piece:hover { transform: scale(1.12); border-color: var(--sun); }

.win-overlay {
  position: absolute; inset: -10px; z-index: 100;
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(6px);
  border-radius: 24px;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 16px;
  animation: popIn 0.6s cubic-bezier(0.175,0.885,0.32,1.275);
}
@keyframes popIn {
  from { transform: scale(0.4); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}
.win-title {
  font-family: 'Fredoka One', cursive;
  font-size: clamp(2rem, 6vw, 3.5rem);
  background: linear-gradient(135deg, var(--sun), var(--coral), var(--mint));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  text-align: center; line-height: 1.1;
}
.stars-row { font-size: 2.5rem; letter-spacing: 4px; }
.win-time { font-size: 1.1rem; color: rgba(255,255,255,0.8); }
.confetti-canvas { position: fixed; inset: 0; pointer-events: none; z-index: 200; }

.preview-img { width: 100%; border-radius: 10px; margin-top: 10px; border: 2px solid rgba(255,255,255,0.2); }

.tutorial-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.75);
  display: flex; align-items: center; justify-content: center; z-index: 500;
}
.tutorial-box {
  background: linear-gradient(135deg, #1e1b4b, #302b63);
  border: 2px solid rgba(255,255,255,0.2);
  border-radius: 24px; padding: 2.5rem; max-width: 420px; text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.tutorial-box h2 { font-family:'Fredoka One',cursive; font-size:2rem; color: var(--sun); margin-bottom: 16px; }
.tutorial-steps { text-align: left; margin: 16px 0; }
.tutorial-step { display: flex; gap: 12px; margin-bottom: 12px; align-items: flex-start; }
.step-num {
  background: linear-gradient(135deg, var(--coral), var(--grape));
  border-radius: 50%; width: 32px; height: 32px; display: flex;
  align-items: center; justify-content: center;
  font-family: 'Fredoka One',cursive; font-size: 1rem; flex-shrink: 0;
}
.step-text { font-size: 0.95rem; color: rgba(255,255,255,0.85); padding-top: 6px; }
.tutorial-btn {
  background: linear-gradient(135deg, var(--coral), var(--grape));
  border: none; border-radius: 50px; padding: 14px 40px;
  font-family:'Fredoka One',cursive; font-size: 1.2rem; color: #fff; cursor: pointer;
  box-shadow: 0 6px 20px rgba(168,85,247,0.4); transition: all 0.2s;
  margin-top: 8px;
}
.tutorial-btn:hover { transform: scale(1.05); }

.hint-overlay {
  position: absolute; inset: 0; pointer-events: none; z-index: 50;
  animation: hintFade 1.5s ease-in-out forwards;
}
@keyframes hintFade { 0%,70%{opacity:1} 100%{opacity:0} }

@media (max-width: 700px) {
  .game-layout { flex-direction: column; }
  .game-layout .sidebar { flex: none; width: 100%; }
}
</style>
</head>
<body>

<div class="stars-bg" id="stars-bg"></div>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// â”€â”€â”€ Audio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function playBeep(freq = 880, dur = 0.12, type = 'sine', vol = 0.25) {
  try {
    const ctx = getAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.frequency.value = freq; osc.type = type;
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
    osc.start(ctx.currentTime); osc.stop(ctx.currentTime + dur);
  } catch(e) {}
}
function playPlace() { playBeep(660, 0.1, 'sine', 0.3); setTimeout(() => playBeep(880, 0.1, 'sine', 0.25), 80); }
function playWin() {
  [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playBeep(f, 0.3, 'sine', 0.3), i * 120));
}
function playError() { playBeep(220, 0.15, 'sawtooth', 0.2); }

// â”€â”€â”€ Jigsaw Shape â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateEdges(rows, cols) {
  const h = Array.from({length: rows-1}, () =>
    Array.from({length: cols}, () => Math.random() > 0.5 ? 1 : -1)
  );
  const v = Array.from({length: rows}, () =>
    Array.from({length: cols-1}, () => Math.random() > 0.5 ? 1 : -1)
  );
  return {h, v};
}

function drawJigsawEdge(ctx, x0, y0, x1, y1, dir) {
  if (dir === 0) { ctx.lineTo(x1, y1); return; }
  const dx = x1-x0, dy = y1-y0;
  const len = Math.sqrt(dx*dx+dy*dy);
  const ux = dx/len, uy = dy/len;
  const rx = uy * dir, ry = -ux * dir;
  const bump = len * 0.22;

  ctx.lineTo(x0 + ux*len*0.30, y0 + uy*len*0.30);
  ctx.bezierCurveTo(
    x0 + ux*len*0.30 + rx*bump*0.6, y0 + uy*len*0.30 + ry*bump*0.6,
    x0 + ux*len*0.42 + rx*bump,     y0 + uy*len*0.42 + ry*bump,
    x0 + ux*len*0.50 + rx*bump,     y0 + uy*len*0.50 + ry*bump
  );
  ctx.bezierCurveTo(
    x0 + ux*len*0.58 + rx*bump,     y0 + uy*len*0.58 + ry*bump,
    x0 + ux*len*0.70 + rx*bump*0.6, y0 + uy*len*0.70 + ry*bump*0.6,
    x0 + ux*len*0.70, y0 + uy*len*0.70
  );
  ctx.lineTo(x1, y1);
}

function buildJigsawPath(ctx, x, y, w, h, e) {
  ctx.beginPath(); ctx.moveTo(x, y);
  drawJigsawEdge(ctx, x,   y,   x+w, y,   e.top);
  drawJigsawEdge(ctx, x+w, y,   x+w, y+h, e.right);
  drawJigsawEdge(ctx, x+w, y+h, x,   y+h, e.bottom);
  drawJigsawEdge(ctx, x,   y+h, x,   y,   e.left);
  ctx.closePath();
}

function createPieceCanvas(img, row, col, rows, cols, edges, boardW, boardH, pieceW, pieceH) {
  const ext = Math.min(pieceW, pieceH) * 0.26;
  const cw = Math.ceil(pieceW + 2*ext);
  const ch = Math.ceil(pieceH + 2*ext);

  const canvas = document.createElement('canvas');
  canvas.width = cw; canvas.height = ch;
  const ctx = canvas.getContext('2d');

  const e = {
    top:    row > 0        ? -edges.h[row-1][col]  : 0,
    right:  col < cols-1   ?  edges.v[row][col]    : 0,
    bottom: row < rows-1   ?  edges.h[row][col]    : 0,
    left:   col > 0        ? -edges.v[row][col-1]  : 0,
  };

  ctx.save();
  buildJigsawPath(ctx, ext, ext, pieceW, pieceH, e);
  ctx.clip();
  ctx.translate(-col*pieceW + ext, -row*pieceH + ext);
  ctx.drawImage(img, 0, 0, boardW, boardH);
  ctx.restore();

  ctx.save();
  buildJigsawPath(ctx, ext+1, ext+1, pieceW, pieceH, e);
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.restore();

  ctx.save();
  buildJigsawPath(ctx, ext, ext, pieceW, pieceH, e);
  ctx.strokeStyle = 'rgba(255,255,255,0.75)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.restore();

  return { src: canvas.toDataURL('image/png'), cw, ch, ext };
}

function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length-1; i > 0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

async function createAllPieces(imgSrc, rows, cols, boardW, boardH) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const edges = generateEdges(rows, cols);
      const pieceW = boardW / cols;
      const pieceH = boardH / rows;
      const pieces = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const p = createPieceCanvas(img, r, c, rows, cols, edges, boardW, boardH, pieceW, pieceH);
          pieces.push({ id: `p-${r}-${c}`, correctIndex: r*cols+c, row: r, col: c, ...p });
        }
      }
      resolve({ pieces: shuffleArray(pieces), pieceW, pieceH, ext: pieces[0].ext });
    };
    img.onerror = (e) => {
      console.error('Image load error:', e);
      reject(new Error('Failed to load image'));
    };
    img.src = imgSrc;
  });
}

// â”€â”€â”€ Confetti â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function Confetti({ active }) {
  const canvasRef = useRef(null);
  const pieces = useRef([]);
  const raf = useRef(null);

  useEffect(() => {
    if (!active) return;
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;

    const colors = ['#FF6B6B','#4ECDC4','#FFE66D','#A855F7','#6EE7B7','#FDBA74','#60A5FA'];
    pieces.current = Array.from({length: 120}, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height - canvas.height,
      w: 8 + Math.random()*10, h: 4 + Math.random()*6,
      color: colors[Math.floor(Math.random()*colors.length)],
      angle: Math.random()*360,
      spin: (Math.random()-0.5)*8,
      vy: 2 + Math.random()*4, vx: (Math.random()-0.5)*3,
      alpha: 1,
    }));

    let frame = 0;
    const animate = () => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      pieces.current.forEach(p => {
        p.y += p.vy; p.x += p.vx; p.angle += p.spin;
        if (frame > 120) p.alpha -= 0.008;
        ctx.save(); ctx.globalAlpha = Math.max(0, p.alpha);
        ctx.translate(p.x, p.y); ctx.rotate(p.angle * Math.PI/180);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      });
      frame++;
      if (frame < 300 && pieces.current.some(p => p.alpha > 0)) {
        raf.current = requestAnimationFrame(animate);
      } else { ctx.clearRect(0,0,canvas.width,canvas.height); }
    };
    raf.current = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(raf.current);
  }, [active]);

  if (!active) return null;
  return <canvas ref={canvasRef} className="confetti-canvas" />;
}

// â”€â”€â”€ Timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function useTimer(running) {
  const [secs, setSecs] = useState(0);
  const start = useRef(Date.now());
  const raf = useRef(null);

  useEffect(() => {
    start.current = Date.now();
    setSecs(0);
  }, [running]);

  useEffect(() => {
    if (!running) return;
    const tick = () => {
      setSecs(Math.floor((Date.now() - start.current) / 1000));
      raf.current = requestAnimationFrame(tick);
    };
    raf.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf.current);
  }, [running]);

  const fmt = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
  return fmt(secs);
}

// â”€â”€â”€ Star rating â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getStars(secs, totalPieces) {
  const par = totalPieces * 8;
  if (secs < par) return 3;
  if (secs < par * 2) return 2;
  return 1;
}

// â”€â”€â”€ Tutorial â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function Tutorial({ onClose }) {
  return (
    <div className="tutorial-overlay" onClick={e => e.target===e.currentTarget && onClose()}>
      <div className="tutorial-box">
        <h2>ğŸ‰ How to Play!</h2>
        <div className="tutorial-steps">
          {[
            ['ğŸ“¸','Upload any photo â€” or use a sample!'],
            ['ğŸ”€','Puzzle pieces will be scrambled in the tray'],
            ['ğŸ–±ï¸','Drag pieces onto the board grid'],
            ['ğŸŠ','Complete the puzzle for a celebration!'],
          ].map(([icon, text], i) => (
            <div className="tutorial-step" key={i}>
              <div className="step-num">{icon}</div>
              <div className="step-text">{text}</div>
            </div>
          ))}
        </div>
        <button className="tutorial-btn" onClick={onClose}>Let's Go! ğŸš€</button>
      </div>
    </div>
  );
}

// â”€â”€â”€ Image Uploader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAMPLES = [
  { label: 'ğŸŒŠ Ocean', url: 'https://picsum.photos/seed/ocean/800/600' },
  { label: 'ğŸŒ² Forest', url: 'https://picsum.photos/seed/forest/800/600' },
  { label: 'ğŸ¦ Animal', url: 'https://picsum.photos/seed/animals/800/600' },
  { label: 'ğŸŒ† City', url: 'https://picsum.photos/seed/city/800/600' },
];

function ImageUploader({ onSelect }) {
  const ref = useRef(null);
  const handleFile = e => {
    const f = e.target.files[0];
    if (!f) return;
    if (!f.type.startsWith('image/')) { alert('Please pick an image!'); return; }
    if (f.size > 8*1024*1024) { alert('File too large (max 8MB)'); return; }
    const reader = new FileReader();
    reader.onload = ev => onSelect(ev.target.result);
    reader.onerror = () => alert('Error reading file');
    reader.readAsDataURL(f);
  };

  const loadSample = (url) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const c = document.createElement('canvas');
      c.width = img.width; c.height = img.height;
      c.getContext('2d').drawImage(img,0,0);
      onSelect(c.toDataURL());
    };
    img.onerror = () => alert("Couldn't load sample â€” try uploading your own image!");
    img.src = url;
  };

  return (
    <div className="upload-wrap">
      <div className="upload-zone" onClick={() => ref.current.click()}
        onKeyDown={e => e.key==='Enter' && ref.current.click()}
        onDragOver={e => e.preventDefault()}
        onDrop={e => { e.preventDefault(); const f=e.dataTransfer.files[0]; if(f){const ev={target:{files:[f]}};handleFile(ev);} }}
        role="button" tabIndex={0}>
        <span className="icon">ğŸ“‚</span>
        <h2>Drop a Photo Here!</h2>
        <p>or click to browse Â· JPG, PNG, GIF</p>
        <input type="file" ref={ref} onChange={handleFile} accept="image/*" hidden />
      </div>
      <div style={{display:'flex',gap:'10px',flexWrap:'wrap',justifyContent:'center'}}>
        {SAMPLES.map(s => (
          <button key={s.label} className="sample-btn" onClick={() => loadSample(s.url)} style={{padding:'10px 20px',fontSize:'0.95rem'}}>
            {s.label}
          </button>
        ))}
      </div>
      <p style={{opacity:0.5,fontSize:'0.85rem'}}>â† Try one of these sample images!</p>
    </div>
  );
}

// â”€â”€â”€ Piece Number Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function PieceBadge({ num, cw, ch, ext }) {
  return (
    <div style={{
      position:'absolute', left: ext+4, top: ext+4, zIndex:5,
      background:'rgba(255,255,255,0.9)', color:'#1E1B4B',
      fontFamily:"'Fredoka One',cursive", fontSize: Math.min(cw,ch)*0.15,
      width: Math.min(cw,ch)*0.25, height: Math.min(cw,ch)*0.25,
      borderRadius:'50%', display:'flex', alignItems:'center', justifyContent:'center',
      boxShadow:'0 2px 6px rgba(0,0,0,0.3)', pointerEvents:'none',
    }}>
      {num}
    </div>
  );
}

// â”€â”€â”€ Puzzle Board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DIFFICULTY = {
  Easy:   { rows:2, cols:3, label:'Easy (6 pcs)' },
  Medium: { rows:3, cols:4, label:'Medium (12 pcs)' },
  Hard:   { rows:4, cols:5, label:'Hard (20 pcs)' },
  Expert: { rows:5, cols:6, label:'Expert (30 pcs)' },
};

function PuzzleGame({ imgSrc, onNewImage }) {
  const [diff, setDiff] = useState('Easy');
  const [slots, setSlots] = useState([]);
  const [pile, setPile] = useState([]);
  const [meta, setMeta] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isComplete, setIsComplete] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [showNumbers, setShowNumbers] = useState(false);
  const [showHint, setShowHint] = useState(false);
  const [score, setScore] = useState(0);
  const [placedCount, setPlacedCount] = useState(0);
  const [hoverSlot, setHoverSlot] = useState(null);
  const [dragData, setDragData] = useState(null);
  const [dragPos, setDragPos] = useState({ x: 0, y: 0 });
  const timer = useTimer(!isComplete && slots.length > 0);

  const boardW = Math.min(560, Math.max(280, (typeof window !== 'undefined' ? window.innerWidth : 800) - 260));
  const boardH = Math.round(boardW * 0.75);

  const boardRef = useRef(null);
  const boardGridRef = useRef(null);
  const timerStartRef = useRef(Date.now());
  const pileRef = useRef(pile);
  const slotsRef = useRef(slots);
  const metaRef = useRef(meta);

  useEffect(() => { pileRef.current = pile; }, [pile]);
  useEffect(() => { slotsRef.current = slots; }, [slots]);
  useEffect(() => { metaRef.current = meta; }, [meta]);

  const initGame = useCallback(async () => {
    setLoading(true); 
    setIsComplete(false); 
    setPlacedCount(0); 
    setHoverSlot(null);
    setDragData(null);
    setScore(0);
    timerStartRef.current = Date.now();
    
    const { rows, cols } = DIFFICULTY[diff];
    try {
      const { pieces, pieceW, pieceH, ext } = await createAllPieces(imgSrc, rows, cols, boardW, boardH);
      setMeta({ pieceW, pieceH, ext, rows, cols });
      setSlots(Array(rows*cols).fill(null));
      setPile(pieces);
    } catch(e) { 
      console.error('Error loading image:', e);
      alert('Error loading image. Please try a different image.');
      onNewImage();
    }
    setLoading(false);
  }, [imgSrc, diff, boardW, boardH, onNewImage]);

  useEffect(() => { 
    initGame(); 
  }, [initGame]);

  const startDrag = useCallback((e, piece, sourceType, sourceIndex) => {
    if (isComplete || loading) return;
    
    // Check if piece is correctly placed (locked)
    if (sourceType === 'slot' && piece.correctIndex === sourceIndex) {
      return;
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    const rect = e.currentTarget.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    setDragData({ 
      piece, 
      sourceType, 
      sourceIndex,
      pointerId: e.pointerId
    });
    setDragPos({ x: e.clientX, y: e.clientY, offsetX: e.clientX - centerX, offsetY: e.clientY - centerY });
    
    try {
      e.currentTarget.setPointerCapture(e.pointerId);
    } catch(err) {
      console.warn('Could not capture pointer:', err);
    }
  }, [isComplete, loading]);

  const handlePointerMove = useCallback((e) => {
    if (!dragData) return;
    
    setDragPos(prev => ({ ...prev, x: e.clientX, y: e.clientY }));
    
    const grid = boardGridRef.current;
    const m = metaRef.current;
    if (grid && m) {
      const rect = grid.getBoundingClientRect();
      const col = Math.floor((e.clientX - rect.left) / m.pieceW);
      const row = Math.floor((e.clientY - rect.top) / m.pieceH);
      if (col >= 0 && col < m.cols && row >= 0 && row < m.rows) {
        setHoverSlot(row * m.cols + col);
      } else {
        setHoverSlot(null);
      }
    }
  }, [dragData]);

  const handlePointerUp = useCallback((e) => {
    if (!dragData) return;
    
    const cx = e.clientX, cy = e.clientY;
    let targetIdx = null;
    
    const grid = boardGridRef.current;
    const m = metaRef.current;
    if (grid && m) {
      const rect = grid.getBoundingClientRect();
      const col = Math.floor((cx - rect.left) / m.pieceW);
      const row = Math.floor((cy - rect.top) / m.pieceH);
      if (col >= 0 && col < m.cols && row >= 0 && row < m.rows) {
        targetIdx = row * m.cols + col;
      }
    }

    setSlots(prevSlots => {
      const newSlots = [...prevSlots];
      let newPile = [...pileRef.current];
      
      // Remove from source
      if (dragData.sourceType === 'slot' && dragData.sourceIndex !== null && dragData.sourceIndex !== undefined) {
        newSlots[dragData.sourceIndex] = null;
      } else {
        newPile = newPile.filter(p => p.id !== dragData.piece.id);
      }

      if (targetIdx !== null && targetIdx !== undefined) {
        // Drop on board
        const existing = newSlots[targetIdx];
        if (existing) { 
          newPile.push(existing); 
        }
        newSlots[targetIdx] = dragData.piece;
        
        if (dragData.piece.correctIndex === targetIdx) { 
          playPlace(); 
        } else {
          playError();
        }
      } else {
        // Dropped outside board - return to pile
        newPile.push(dragData.piece);
        playError();
      }
      
      setPile(newPile);
      
      const placed = newSlots.filter(Boolean).length;
      setPlacedCount(placed);

      const win = newSlots.every((p, i) => p && p.correctIndex === i);
      if (win) {
        const secs = Math.floor((Date.now() - timerStartRef.current) / 1000);
        setIsComplete(true);
        setScore(getStars(secs, newSlots.length));
        setTimeout(() => playWin(), 200);
      }
      
      return newSlots;
    });
    
    setDragData(null);
    setHoverSlot(null);
  }, [dragData]);

  useEffect(() => {
    if (!dragData) return;
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);
    return () => { 
      window.removeEventListener('pointermove', handlePointerMove); 
      window.removeEventListener('pointerup', handlePointerUp); 
    };
  }, [dragData, handlePointerMove, handlePointerUp]);

  const triggerHint = () => { setShowHint(true); setTimeout(() => setShowHint(false), 1500); };

  const total = meta ? meta.rows * meta.cols : 0;

  return (
    <div>
      <div className="stats-bar">
        <div className="stat-chip">â± {timer}</div>
        <div className="stat-chip">ğŸ§© {placedCount}/{total}</div>
        <div className="stat-chip" style={{background:'rgba(255,230,109,0.2)'}}>â­ {score ? 'â­'.repeat(score) : 'â€”'}</div>
      </div>

      <div className="game-layout">
        <div className="sidebar">
          <div className="sidebar-section">
            <label>Difficulty</label>
            <select value={diff} onChange={e => setDiff(e.target.value)} disabled={loading}>
              {Object.entries(DIFFICULTY).map(([k,v]) => <option key={k} value={k}>{v.label}</option>)}
            </select>
          </div>
          <button className="btn btn-primary" onClick={initGame} disabled={loading}>ğŸ”„ New Puzzle</button>
          <button className="btn btn-teal" onClick={triggerHint} disabled={loading || isComplete}>ğŸ’¡ Flash Hint</button>
          <button className="btn btn-purple" onClick={() => setShowNumbers(v => !v)} disabled={loading}>
            {showNumbers ? 'ğŸ”¢ Hide Numbers' : 'ğŸ”¢ Show Numbers'}
          </button>
          <button className="btn btn-outline" onClick={() => setShowPreview(v => !v)} disabled={loading}>
            {showPreview ? 'ğŸ™ˆ Hide Preview' : 'ğŸ‘ Preview'}
          </button>
          <button className="btn btn-outline" style={{marginTop:6}} onClick={onNewImage} disabled={loading}>ğŸ“‚ New Image</button>

          {showPreview && <img src={imgSrc} alt="Preview" className="preview-img" />}
        </div>

        <div className="main-area">
          {loading ? (
            <div style={{textAlign:'center',padding:'3rem',fontSize:'2rem'}}>
              <div style={{animation:'bounce 0.8s ease-in-out infinite'}}>ğŸ§©</div>
              <p style={{fontFamily:'Fredoka One',color:'rgba(255,255,255,0.7)',marginTop:12}}>Cutting piecesâ€¦</p>
            </div>
          ) : meta ? (
            <>
              <div className="board-area" ref={boardRef}>
                <div className="board-wrap" style={{width:boardW,height:boardH,position:'relative'}}>
                  {showHint && (
                    <div className="hint-overlay">
                      <img src={imgSrc} style={{width:'100%',height:'100%',objectFit:'cover',borderRadius:8,opacity:0.55}} alt="hint"/>
                    </div>
                  )}
                  <div className="puzzle-board" ref={boardGridRef} style={{
                    gridTemplateColumns: `repeat(${meta.cols}, ${meta.pieceW}px)`,
                    gridTemplateRows: `repeat(${meta.rows}, ${meta.pieceH}px)`,
                    width: boardW, height: boardH,
                  }}>
                    {slots.map((piece, idx) => {
                      const isCorrectSlot = piece && piece.correctIndex === idx;
                      const isHovered = hoverSlot === idx;
                      const isCorrectPieceForSlot = dragData && dragData.piece.correctIndex === idx;
                      const canDrag = !isComplete && !isCorrectSlot;
                      
                      return (
                        <div 
                          key={idx} 
                          className={`puzzle-slot ${isHovered ? 'hover-target' : ''} ${isCorrectPieceForSlot ? 'correct-target' : ''}`}
                          style={{width:meta.pieceW,height:meta.pieceH}}
                          data-slot-index={idx}
                        >
                          <div className="slot-inner">
                            {!piece && <span className="slot-hint">{idx+1}</span>}
                          </div>
                          {piece && (
                            <div style={{position:'absolute',left:-meta.ext,top:-meta.ext,zIndex:10,pointerEvents:'none'}}>
                              <img
                                src={piece.src}
                                style={{
                                  width:piece.cw,
                                  height:piece.ch,
                                  display:'block',
                                  pointerEvents: canDrag ? 'all' : 'none',
                                  cursor: canDrag ? 'grab' : 'default'
                                }}
                                className={`piece-img ${!canDrag ? 'locked' : ''} ${isCorrectSlot ? 'placed' : ''}`}
                                onPointerDown={e => canDrag && startDrag(e, piece, 'slot', idx)}
                                draggable={false}
                                alt="piece"
                              />
                              {showNumbers && <PieceBadge num={piece.correctIndex+1} cw={piece.cw} ch={piece.ch} ext={meta.ext}/>}
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>

                  {isComplete && (
                    <div className="win-overlay">
                      <div className="win-title">You Did It! ğŸ‰</div>
                      <div className="stars-row">{'â­'.repeat(score)}{'ğŸŒŸ'.repeat(Math.max(0,3-score))}</div>
                      <div className="win-time">â± {timer} Â· {total} pieces!</div>
                      <button className="btn btn-primary" style={{width:'auto',padding:'12px 32px'}} onClick={initGame}>ğŸ”„ Play Again!</button>
                    </div>
                  )}
                </div>
              </div>

              <div className="pile-section">
                <div className="pile-title">ğŸ—ƒ Piece Tray ({pile.length} left)</div>
                <div className="pile-container">
                  {pile.map(piece => {
                    const scale = 55 / Math.max(piece.cw, piece.ch);
                    return (
                      <div key={piece.id} style={{position:'relative'}}>
                        <img
                          src={piece.src}
                          className="pile-piece"
                          style={{width:piece.cw*scale,height:piece.ch*scale,display:'block'}}
                          onPointerDown={e => startDrag(e, piece, 'pile', null)}
                          draggable={false} 
                          alt="piece"
                        />
                        {showNumbers && (
                          <div style={{position:'absolute',top:2,left:2,background:'rgba(255,255,255,0.9)',color:'#1E1B4B',fontFamily:"'Fredoka One',cursive",fontSize:9,padding:'1px 4px',borderRadius:10,pointerEvents:'none'}}>
                            {piece.correctIndex+1}
                          </div>
                        )}
                      </div>
                    );
                  })}
                  {pile.length === 0 && (
                    <p style={{opacity:0.5,fontFamily:'Fredoka One',fontSize:'0.9rem',padding:'8px 0'}}>All pieces placed! ğŸŠ</p>
                  )}
                </div>
              </div>
            </>
          ) : null}
        </div>
      </div>

      {dragData && (
        <img
          src={dragData.piece.src}
          className="drag-ghost"
          style={{
            left: dragPos.x - dragPos.offsetX,
            top: dragPos.y - dragPos.offsetY,
            width: dragData.piece.cw,
            height: dragData.piece.ch,
          }}
          alt="dragging"
        />
      )}

      <Confetti active={isComplete} />
    </div>
  );
}

// â”€â”€â”€ App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function App() {
  const [imgSrc, setImgSrc] = useState(null);
  const [showTutorial, setShowTutorial] = useState(() => {
    try {
      return !localStorage.getItem('jigsawTutorialSeen');
    } catch(e) {
      return true;
    }
  });

  useEffect(() => {
    const bg = document.getElementById('stars-bg');
    if (!bg || bg.childNodes.length > 0) return;
    for (let i = 0; i < 80; i++) {
      const s = document.createElement('div');
      s.className = 'star';
      const size = 1 + Math.random()*3;
      s.style.cssText = `width:${size}px;height:${size}px;left:${Math.random()*100}%;top:${Math.random()*100}%;--d:${2+Math.random()*4}s;animation-delay:${-Math.random()*4}s`;
      bg.appendChild(s);
    }
    const colors = ['#FF6B6B','#4ECDC4','#FFE66D','#A855F7','#6EE7B7'];
    for (let i = 0; i < 8; i++) {
      const f = document.createElement('div');
      f.className = 'floater';
      const size = 60 + Math.random()*120;
      f.style.cssText = `width:${size}px;height:${size}px;left:${Math.random()*100}%;top:${Math.random()*100}%;background:${colors[i%colors.length]};--fd:${6+Math.random()*8}s;animation-delay:${-Math.random()*8}s`;
      bg.appendChild(f);
    }
  }, []);

  const closeTutorial = () => {
    setShowTutorial(false);
    try {
      localStorage.setItem('jigsawTutorialSeen', '1');
    } catch(e) {}
  };

  return (
    <div className="app">
      <header className="header">
        <h1>ğŸ§© Jigsaw Adventure!</h1>
        <p>Upload a photo, cut it up, solve the puzzle!</p>
      </header>

      {showTutorial && <Tutorial onClose={closeTutorial} />}

      {!imgSrc
        ? <ImageUploader onSelect={setImgSrc} />
        : <PuzzleGame imgSrc={imgSrc} onNewImage={() => setImgSrc(null)} />
      }
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>